# 2. Java Collections 

- I part
    - Difference between array and collections
    - Iterator
    - Collection tree (briefly about each collection interface)
- II part
    - Sortable Collections
    - HashMap, HashSet
    - ArrayList, LinkedList
- III part
    - TreeMap + complexity of search, add, remove

## Part I

### Разница между массивом и коллекциями по типам элементов

int[] cats = new int[10] в памяти выглядит как непрерывная область память заполненная значениями и равная sizeof(int) * 10. Преимущества - если вы часто обращаетесь и бегаете по коллекции элементов то массивы обеспечат вам максимальную производительность только за счет индексной адресации и меньшего количества кэш-мисов (гуглить свойство локальности данных). Минусы - фиксированный размер, заресайзить можно до не удобно и дорого в плане производительности.

ArrayList же это список, обычный такой вот список. То есть каждый элемент связан друг с другом через указатели. Плюсы - легко добавлять и удалять элементы. Минусы - элементы созданные в разное время могут оказаться в память черти где, что может привести к большому количеству кэш-мисов. Короче траверсинг по списку банально медленнее.

ArrayList это реализация списка на массивах, так что все чуть сложнее. Описанный мной случай - LinkedList, но суть все та же - просто массивы - фиксированный размер, ArrayList - размер динамический.

В зависимости от задачи имеет смысла выбирать то или иное решение.

**Чем коллекции лучше массивов?**

В них больше функционала, делать это над массивами зачастую нецелесообразно (или плохое качество кода или долго реализовывать или требуют хорошего понимания алгоритмов).

**Когда лучше использовать массивы, чем коллекции?**

Когда нужно хранить набор данных фиксированного размера.

### Итератор

Ссылки: https://metanit.com/java/tutorial/5.10.php

Одним из ключевых методов интерфейса Collection является метод Iterator<E> iterator(). Он возвращает итератор - то есть объект, реализующий интерфейс Iterator.

```java
public interface Iterator <E>{
    E next();
    boolean hasNext();
    void remove();
}
```

Реализация интерфейса предполагает, что с помощью вызова метода next() можно получить следующий элемент. С помощью метода hasNext() можно узнать, есть ли следующий элемент, и не достигнут ли конец коллекции. И если элементы еще имеются, то hasNext() вернет значение true. Метод hasNext() следует вызывать перед методом next(), так как при достижении конца коллекции метод next() выбрасывает исключение NoSuchElementException. И метод remove() удаляет текущий элемент, который был получен последним вызовом next().

Используем итератор для перебора коллекции ArrayList:

```java
import java.util.*;
 
public class Program {
    public static void main(String[] args) {
        ArrayList<String> states = new ArrayList<String>();
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Spain");
         
        Iterator<String> iter = states.iterator();
        while(iter.hasNext()){
            System.out.println(iter.next());
        }
    }
}
```

Интерфейс Iterator предоставляет ограниченный функционал. Гораздо больший набор методов предоставляет другой итератор - интерфейс ListIterator. Данный итератор используется классами, реализующими интерфейс List, то есть классами LinkedList, ArrayList и др.

Интерфейс ListIterator расширяет интерфейс Iterator и определяет ряд дополнительных методов:

- void add(E obj): вставляет объект obj перед элементом, который должен быть возвращен следующим вызовом next()
- boolean hasNext(): возвращает true, если в коллекции имеется следующий элемент, иначе возвращает false
- boolean hasPrevious(): возвращает true, если в коллекции имеется предыдущий элемент, иначе возвращает false
- E next(): возвращает текущий элемент и переходит к следующему, если такого нет, то генерируется исключение NoSuchElementException
- E previous(): возвращает текущий элемент и переходит к предыдущему, если такого нет, то генерируется исключение NoSuchElementException
- int nextIndex(): возвращает индекс следующего элемента. Если такого нет, то возвращается размер списка
- int previousIndex(): возвращает индекс предыдущего элемента. Если такого нет, то возвращается число -1
- void remove(): удаляет текущий элемент из списка. Таким образом, этот метод должен быть вызван после методов next() или previous(), иначе будет сгенерировано исключение IlligalStateException
- void set(E obj): присваивает текущему элементу, выбранному вызовом методов next() или previous(), ссылку на объект obj

Используем ListIterator:

```java
import java.util.*;

public class Program {

    public static void main(String[] args) {
        ArrayList<String> states = new ArrayList<String>();
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Spain");
    
        ListIterator<String> listIter = states.listIterator();
        
        while(listIter.hasNext()){
            System.out.println(listIter.next());
        }
        // сейчас текущий элемент - Испания
        // изменим значение этого элемента
        listIter.set("Португалия");
        // пройдемся по элементам в обратном порядке
        while(listIter.hasPrevious()){
            System.out.println(listIter.previous());
        } 
    }
}
```

### Дерево коллекций (вкратце про каждый интерфейс коллекций)

![Иерархия коллекций](img/collections-hierarchy.png)

**Базовые понятия**

**Collection** — этот интерфейс находится в составе JDK c версии 1.2 и определяет основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (например size(), isEmpty(), add(E e) и др.). Интерфейс был слегка доработан с приходом дженериков в Java 1.5. Также, в версии Java 8, было добавлено несколько новых методов для работы с лямбдами (такие как stream(), parallelStream(), removeIf(Predicate<? super E> filter) и др.). Важно также отметить, что эти методы были реализованы непосредственно в интерфейсе как default-методы. f

**Map**. Данный интерфейс также находится в составе JDK c версии 1.2 и предоставляет разработчику базовые методы для работы с данными вида «ключ — значение».Также как и Collection, он был дополнен дженериками в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые зачастую реализовались в логике приложения (getOrDefault(Object key, V defaultValue), putIfAbsent(K key, V value)).

**Интерфейс Map**

**Hashtable** — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии была включена в его состав. Как и другие коллекции из Java 1.0, Hashtable является синхронизированной (почти все методы помечены как synchronized). Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду отсутствия у них синхронизации. 

**HashMap** — коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения. Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n). Более подробную информацию о HashMap можно почитать здесь (актуально для Java < 8). 

**LinkedHashMap** — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList). Но это преимущество имеет также и недостаток — увеличение памяти, которое занимет коллекция. Более подробная информация изложена в этой статье. 

**TreeMap** — реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании объекта TreeMap. 

**WeakHashMap** — реализация хэш-таблицы, которая организована с использованием weak references. Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких ссылок.

**Интерфейс List**

Реализации этого интерфейса представляют собой упорядоченные коллекции. Кроме того, разработчику предоставляется возможность доступа к элементам коллекции по индексу и по значению (так как реализации позволяют хранить дубликаты, результатом поиска по значению будет первое найденное вхождение). 

**Vector** — реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Vector появился в JDK версии Java 1.0, но как и Hashtable, эту коллекцию не рекомендуется использовать, если не требуется достижения потокобезопасности. Потому как в Vector, в отличии от других реализаций List, все операции с данными являются синхронизированными. В качестве альтернативы часто применяется аналог — ArrayList. 

**Stack** — данная коллекция является расширением коллекции Vector. Была добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является частично синхронизированной коллекцией (кроме метода добавления push()). После добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно реализации этого интерфейса, например ArrayDeque. 

**ArrayList** — как и Vector является реализацией динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Как можно догадаться из названия, его реализация основана на обычном массиве. Данную реализацию следует применять, если в процессе работы с коллекцией предплагается частое обращение к элементам по индексу. Из-за особенностей реализации поиндексное обращение к элементам выполняется за константное время O(1). Но данную коллекцию рекомендуется избегать, если требуется частое удаление/добавление элементов в середину коллекции. Подробный анализ и описание можно почитать в этом хабратопике. 

**LinkedList** — ещё одна реализация List. Позволяет хранить любые данные, включая null. Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий). Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца за константное O(1). Так же, ввиду реализации, данную коллекцию можно использовать как стек или очередь. Для этого в ней реализованы соответствующие методы. На Хабре также есть статья с подробным анализом и описанием этой коллекции.

**Set** расширяет интерфейс Collection и представляет набор уникальных элементов. Set не добавляет новых методов, только вносит изменения унаследованные. В частности, метод add() добавляет элемент в коллекцию и возвращает true, если в коллекции еще нет такого элемента. Обобщенный класс HashSet представляет хеш-таблицу. Он наследует свой функционал от класса AbstractSet, а также реализует интерфейс Set. Хеш-таблица представляет такую структуру данных, в которой все объекты имеют уникальный ключ или хеш-код. Данный ключ позволяет уникально идентифицировать объект в таблице.

**Интерфейс Queue**

Этот интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно — очереди FIFO (first-in-first-out). Помимо методов, определённых в интерфейсе Collection, определяет дополнительные методы для извлечения и добавления элементов в очередь. Большинство реализаций данного интерфейса находится в пакете java.util.concurrent и подробно рассматриваются в данном обзоре. 

**PriorityQueue** — является единственной прямой реализацией интерфейса Queue (была добавлена, как и интерфейс Queue, в Java 1.5), не считая класса LinkedList, который так же реализует этот интерфейс, но был реализован намного раньше. Особенностью данной очереди является возможность управления порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов. 

**ArrayDeque** — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out). Интерфейс Deque и реализация ArrayDeque были добавлены в Java 1.6. Эта коллекция представляет собой реализацию с использованием массивов, подобно ArrayList, но не позволяет обращаться к элементам по индексу и хранение null. Как заявлено в документации, коллекция работает быстрее чем Stack, если используется как LIFO коллекция, а также быстрее чем LinkedList, если используется как FIFO.

## II part

### Сортируемые коллекции

Ссылка: http://java-course.ru/begin/collections_01

Я выделю два пути, которые позволяют сортировать коллекции:

- Использовать коллекцию с реализацией интерфейса SortedSet, SortedMap (TreeSet, TreeMap)
- Использовать метод sort класса java.util.Collections (Vector, Stack, ArrayList, LinkedList)

В первом случае (и частично во втором тоже) на класс, который вы храните в коллекции, накладывается требование — он должен реализовать интерфейс . При использовании SortedSet сортировка происходит сразу после добавления. Я предлагаю вам проверить это в качестве домашнего задания. В случае использования метода sort класса java.util.Collections вам потребуется создать класс, который реализует интерфейс java.util.Comparator. Задача этого класса очень простая — он должен сравнить два объекта.

### HashMap, HashSet

HashSet - это множество, например {1,2,3,4,5}

HashMap - это карта key - > value (ключ к значению), например {a -> 1, b - > 2, c - > 2, d - > 1}

Обратите внимание в моем примере выше, что в HashMap не должно быть повторяющихся ключей, но он может иметь повторяющиеся значения.

В HashSet не должно быть повторяющихся элементов.

### ArrayList, LinkedList

Ссылка: https://javarush.ru/quests/lectures/questsyntax.level08.lecture05

— ArrayList реализован внутри в виде обычного массива. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. Зато в нем быстро реализованы взятие и изменение элемента – операции get, set, так как в них мы просто обращаемся к соответствующему элементу массива.

— LinkedList реализован внутри по-другому. Он реализован в виде связного списка: набора отдельных элементов, каждый из которых хранит ссылку на следующий и предыдущий элементы. Чтобы вставить элемент в середину такого списка, достаточно поменять ссылки его будущих соседей. А вот чтобы получить элемент с номером 130, нужно пройтись последовательно по всем объектам от 0 до 130. Другими словами операции set и get тут реализованы очень медленно.

|Описание|Операция|ArrayList|LinkedList|
|---|---|---|---|
|Взятие элемента|get|Быстро|Медленно|
|Присваивание элемента|set|Быстро|Медленно|
|Добавление элемента|add|Быстро|Быстро|
|Вставка элемента|add(i, value)|Медленно|Быстро|
|Удаление элемента|remove|Медленно|Быстро|

### TreeMap и сложность операций поиска элемента, добавления

Ссылка: https://javarush.ru/groups/posts/2584-osobennosti-treemap